# src/taskdantic/uda_sync.py
from __future__ import annotations

import importlib
import os
from pathlib import Path
from typing import Iterable

from taskdantic.models import Task
from taskdantic.uda_export import extract_uda_specs, merge_uda_specs, render_taskrc_udas


BEGIN_MARKER = "# BEGIN TASKDANTIC UDAS (autogenerated)"
END_MARKER = "# END TASKDANTIC UDAS (autogenerated)"


def _iter_all_subclasses(cls: type) -> Iterable[type]:
    seen: set[type] = set()
    stack = list(cls.__subclasses__())
    while stack:
        sub = stack.pop()
        if sub in seen:
            continue
        seen.add(sub)
        yield sub
        stack.extend(sub.__subclasses__())


def discover_task_models(*, import_modules: list[str] | None = None) -> list[type[Task]]:
    """
    Discover Task subclasses currently importable in this process.

    If `import_modules` is provided, import them first to ensure their subclasses are registered.
    """
    if import_modules:
        for mod in import_modules:
            mod = mod.strip()
            if not mod:
                continue
            importlib.import_module(mod)

    models: list[type[Task]] = []
    for sub in _iter_all_subclasses(Task):
        # Only concrete Task subclasses
        if not isinstance(sub, type):
            continue
        models.append(sub)  # type: ignore[assignment]
    return models


def parse_existing_uda_names(taskrc_text: str) -> set[str]:
    """
    Best-effort parse: find any lines like `uda.<name>.type=...` in the existing taskrc.
    """
    names: set[str] = set()
    for raw in taskrc_text.splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("uda.") and ".type=" in line:
            # uda.<name>.type=...
            try:
                rest = line[len("uda.") :]
                name = rest.split(".type=", 1)[0].strip()
                if name:
                    names.add(name)
            except Exception:
                continue
    return names


def upsert_managed_block(taskrc_text: str, block_body: str) -> str:
    """
    Replace the managed block if present; otherwise append it.
    """
    managed = (
        f"{BEGIN_MARKER}\n# Generated from Pydantic Task models. Do not edit by hand.\n\n{block_body}\n{END_MARKER}\n"
    )

    if BEGIN_MARKER in taskrc_text and END_MARKER in taskrc_text:
        pre, rest = taskrc_text.split(BEGIN_MARKER, 1)
        _, post = rest.split(END_MARKER, 1)
        # Keep surrounding newlines sane
        pre = pre.rstrip() + "\n\n"
        post = post.lstrip()
        return pre + managed + "\n" + post

    # Append
    sep = "\n\n" if not taskrc_text.endswith("\n") else "\n"
    return taskrc_text + sep + managed


def sync_taskrc_udas(*, taskrc_path: str, import_modules: list[str] | None = None) -> None:
    """
    Generate UDAs from all discovered Task subclasses and upsert them into taskrc.
    """
    path = Path(taskrc_path).expanduser()
    if not path.exists():
        raise FileNotFoundError(f"TASKRC_PATH does not exist: {path}")

    original = path.read_text(encoding="utf-8")
    existing = parse_existing_uda_names(original)

    models = discover_task_models(import_modules=import_modules)
    spec_map = merge_uda_specs(extract_uda_specs(m) for m in models)
    generated_names = set(spec_map.keys())

    # Compare (you can tighten this to raise if you want strict drift detection)
    missing_in_code = existing - generated_names
    if missing_in_code:
        # Keep it lightweight: warn via stderr so it shows in logs but doesn't break.
        # If you prefer strict mode, change to `raise ValueError(...)`.
        import sys

        print(
            f"[taskdantic] Warning: taskrc defines UDAs not generated from code: {sorted(missing_in_code)}",
            file=sys.stderr,
        )

    block_body = render_taskrc_udas(spec_map.values())
    updated = upsert_managed_block(original, block_body)

    if updated != original:
        tmp = path.with_suffix(path.suffix + ".tmp")
        tmp.write_text(updated, encoding="utf-8")
        tmp.replace(path)


def auto_sync_taskrc_from_env() -> None:
    """
    Startup hook:
      - If TASKRC_PATH is set: sync UDAs into that file.
      - Optionally import extra modules before discovery via TASKDANTIC_TASK_MODULES
        (comma-separated module paths).
    """
    taskrc_path = os.getenv("TASKRC_PATH")
    if not taskrc_path:
        return

    mods_env = os.getenv("TASKDANTIC_TASK_MODULES", "")
    import_modules = [m.strip() for m in mods_env.split(",") if m.strip()]

    sync_taskrc_udas(taskrc_path=taskrc_path, import_modules=import_modules)


if __name__ == "__main__":
    auto_sync_taskrc_from_env()
