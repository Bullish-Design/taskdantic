# src/taskdantic/uda_sync.py
from __future__ import annotations

import ast
import hashlib
import importlib.util
import os
import sys
from pathlib import Path
from typing import Iterable

from taskdantic.models import Task
from taskdantic.uda_export import extract_uda_specs, merge_uda_specs, render_taskrc_udas

from dotenv import load_dotenv

load_dotenv()

BEGIN_MARKER = "# BEGIN TASKDANTIC UDAS (autogenerated)"
END_MARKER = "# END TASKDANTIC UDAS (autogenerated)"


def _iter_all_subclasses(cls: type) -> Iterable[type]:
    seen: set[type] = set()
    stack = list(cls.__subclasses__())
    while stack:
        sub = stack.pop()
        if sub in seen:
            continue
        seen.add(sub)
        yield sub
        stack.extend(sub.__subclasses__())


def _file_imports_task_class(py_text: str) -> bool:
    """
    Return True if a file imports `Task` from any `taskdantic...` module.

    We intentionally only match explicit imports like:
      - from taskdantic import Task
      - from taskdantic.models import Task
      - from taskdantic.something import Task

    This keeps imports targeted and avoids importing unrelated files.
    """
    if "taskdantic" not in py_text or "Task" not in py_text:
        return False

    try:
        tree = ast.parse(py_text)
    except SyntaxError:
        return False

    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom):
            mod = node.module or ""
            if not mod.startswith("taskdantic"):
                continue
            for alias in node.names:
                if alias.name == "Task":
                    return True
    return False


def _import_module_from_path(path: Path) -> None:
    """
    Import a python file by absolute path as an anonymous module.
    """
    # stable-ish unique module name to avoid collisions
    digest = hashlib.sha1(str(path).encode("utf-8")).hexdigest()[:12]
    mod_name = f"taskdantic_autoload_{digest}"

    spec = importlib.util.spec_from_file_location(mod_name, str(path))
    if spec is None or spec.loader is None:
        return

    module = importlib.util.module_from_spec(spec)
    sys.modules[mod_name] = module
    spec.loader.exec_module(module)  # type: ignore[union-attr]


def import_task_modules_from_dir(root_dir: str | Path) -> list[Path]:
    """
    Recursively scan root_dir for *.py files that import Task from taskdantic,
    and import them. Returns list of imported file paths.
    """
    root = Path(root_dir).expanduser().resolve()
    if not root.exists() or not root.is_dir():
        raise NotADirectoryError(f"TASKDANTIC_TASKS_ROOT is not a directory: {root}")

    imported: list[Path] = []

    for path in root.rglob("*.py"):
        # Skip common junk directories
        parts = set(path.parts)
        if "__pycache__" in parts or ".venv" in parts or "venv" in parts:
            continue

        try:
            text = path.read_text(encoding="utf-8")
        except Exception:
            continue

        if not _file_imports_task_class(text):
            continue

        _import_module_from_path(path)
        imported.append(path)

    return imported


def discover_task_models() -> list[type[Task]]:
    """
    Discover Task subclasses currently registered in this process.
    """
    models: list[type[Task]] = []
    for sub in _iter_all_subclasses(Task):
        if isinstance(sub, type):
            models.append(sub)  # type: ignore[assignment]
    return models


def parse_existing_uda_names(taskrc_text: str) -> set[str]:
    names: set[str] = set()
    for raw in taskrc_text.splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("uda.") and ".type=" in line:
            rest = line[len("uda.") :]
            name = rest.split(".type=", 1)[0].strip()
            if name:
                names.add(name)
    return names


def upsert_managed_block(taskrc_text: str, block_body: str) -> str:
    managed = (
        f"{BEGIN_MARKER}\n# Generated from Pydantic Task models. Do not edit by hand.\n\n{block_body}\n{END_MARKER}\n"
    )

    if BEGIN_MARKER in taskrc_text and END_MARKER in taskrc_text:
        pre, rest = taskrc_text.split(BEGIN_MARKER, 1)
        _, post = rest.split(END_MARKER, 1)
        pre = pre.rstrip() + "\n\n"
        post = post.lstrip()
        return pre + managed + "\n" + post

    sep = "\n\n" if not taskrc_text.endswith("\n") else "\n"
    return taskrc_text + sep + managed


def sync_taskrc_udas(*, taskrc_path: str, tasks_root: str | None = None, strict: bool = False) -> None:
    """
    Generate UDAs from all discovered Task subclasses and upsert them into taskrc.

    If tasks_root is provided, import every matching python file under that directory first.
    """
    path = Path(taskrc_path).expanduser()
    if not path.exists():
        raise FileNotFoundError(f"TASKRC_PATH does not exist: {path}")

    if tasks_root:
        import_task_modules_from_dir(tasks_root)

    original = path.read_text(encoding="utf-8")
    existing = parse_existing_uda_names(original)

    models = discover_task_models()
    spec_map = merge_uda_specs(extract_uda_specs(m) for m in models)
    generated_names = set(spec_map.keys())

    missing_in_code = existing - generated_names
    if missing_in_code:
        msg = f"[taskdantic] taskrc defines UDAs not generated from code: {sorted(missing_in_code)}"
        if strict:
            raise ValueError(msg)
        print(msg, file=sys.stderr)

    block_body = render_taskrc_udas(spec_map.values())
    updated = upsert_managed_block(original, block_body)

    if updated != original:
        tmp = path.with_suffix(path.suffix + ".tmp")
        tmp.write_text(updated, encoding="utf-8")
        tmp.replace(path)


def auto_sync_taskrc_from_env() -> None:
    """
    Startup hook:
      - TASKRC_PATH must be set and exist
      - TASKDANTIC_TASKS_ROOT (optional): directory root to scan/import recursively
      - TASKDANTIC_STRICT_UDAS (optional): "1"/"true" to fail on unmanaged UDAs
    """
    print(f"\n[taskdantic] Auto-syncing UDAs into taskrc from environment...")
    from dotenv import load_dotenv

    load_dotenv()
    taskrc_path = os.getenv("TASKRC_PATH")
    print(f"[taskdantic] Using TASKRC_PATH={taskrc_path}")
    if not taskrc_path:
        return

    tasks_root = os.getenv("TASKDANTIC_TASKS_ROOT")
    print(f"[taskdantic] Using TASKDANTIC_TASKS_ROOT={tasks_root}")
    strict_env = os.getenv("TASKDANTIC_STRICT_UDAS", "").strip().lower()
    strict = strict_env in {"1", "true", "yes", "on"}
    print(f"[taskdantic] Using TASKDANTIC_STRICT_UDAS={strict}")

    sync_taskrc_udas(taskrc_path=taskrc_path, tasks_root=tasks_root, strict=strict)
    print(f"[taskdantic] UDA sync complete.\n")


if __name__ == "__main__":
    auto_sync_taskrc_from_env()
